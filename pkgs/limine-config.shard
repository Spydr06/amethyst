{ lib, pkgs, stdenv, config ? {}, ... }:
let
    configFile = "limine.cfg";

    defaultTimeout = 5;
    timeout = config.timeout or defaultTimeout;

    bootDir = /boot;

    mkLimineConfig = { timeout, entries }: builtins.join "\n" $ [
            "# autogenerated by limine-config.shard"
            "TIMEOUT=${timeout}"
            ""
        ] ++ $ builtins.map mkLimineEntry entries;

    mkLimineEntry = { kernel, protocol ? "limine", initrd ? null, cmdline ? "" }:
        builtins.join "\n" $ [
            ":${kernel}"
            "  PROTOCOL=${protocol}"
            "  KERNEL_PATH=boot://${bootDir}/${kernel}"
            "  KERNEL_CMDLINE=${cmdline}"
        ] ++ (builtins.when (initrd != null) "  MODULE_PATH=boot://${initrd}")
          ++ [ "" ];

    getKernelEntries = let
            bootEntry = name :: string: kernel: assert kernel ? package; 
                let
                    fullKernelName = "${name}-${kernel.package.publicVersion}-${geode.architecture}";
                in
                {
                    kernel = "${fullKernelName}.elf";
                    initrd = kernel.initrdFile or null;
                    cmdline = builtins.join " " kernel.arguments or [];
                };

            bootEntries = builtins.attrValues $ builtins.mapAttrs bootEntry config.kernels;
        in { inherit timeout; entries = bootEntries; };
in lib.mkPackage {
    name = "limine-config";
    version = "0.0.1"; 

    buildPhase = stdenv.writeFile configFile $ mkLimineConfig getKernelEntries;

    installPhase = lib.installFile { src = configFile; dst = "${bootDir}/limine/${configFile}"; };
}
